
# 消息队列
**使用队列来通信**的组件。它的本质，就是个**转发器**，包含**发消息、存消息、消费消息**的过程。

**消息队列** 是指利用 **高效可靠** 的 **消息传递机制** 进行与平台无关的 **数据交流**，并基于**数据通信**来进行分布式系统的集成。  
通过提供 **消息传递** 和 **消息排队** 模型，它可以在 **分布式环境** 下提供 **应用解耦**、**弹性伸缩**、**冗余存储**、**流量削峰**、**异步通信**、**数据同步** 等等功能，其作为 **分布式系统架构** 中的一个重要组件，有着举足轻重的地位。

![image.png](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404291638324.png)

# 作用

## 异步处理
用户抽奖成功后，直接返回中奖消息，实际的结果落库通过消息队列处理。

## 应用解耦
如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。


## 流量削峰
>可能导致消息积压

在秒杀情景下，将用户请求写入消息队列，再进行后续业务处理


## 消息通讯
消息队列内置了高效的通信机制，可用于消息通讯。如实现点对点消息队列、聊天室等。



# 存在问题
消息队列挂掉
发送失败重试（重试、重复消息）

重复消费消息
消息的顺序消费
分布式事务
消息堆积


# 解决办法
## 消息可靠性（消息丢失）
生产者不丢消息、消息队列不丢消息、消费者不丢消息
- 生产者：同步发送，发送成功返回ACK，发送失败重试（**重复发送**）
- 消息队列：消息持久化到磁盘（同步刷盘、异步刷盘）、主从集群部署（同步复制、异步复制）
- 消费者：消费成功确认、死信队列、消息补偿机制。

## 消息顺序性
- 消息发到同一个队列，当M1发送完收到ack后，M2再发送（无法保证消费者接收顺序）
- 将M1和M2发送到同一个消费者，发送M1后，等到消费端ACK成功后，才发送M2

## 高可用
持久化存储
主从：主节点的数据会同步给从节点，主节点出问题后，从节点可以顶上来提供服务，同时从节点也可以提供读的操作，为主节点减轻压力。
分片：在设计的时候还要考虑数据分片的场景，一个Topic的数据可以分成很多份进行存储，分别存储在不同的Broker上，这样当磁盘不够的时候，可以通过增加Broker的节点来扩容。

## 重复消费
- 生产端为了保证消息的可靠性，它可能往MQ服务器重复发送消息，直到拿到成功的ACK。
- 再然后就是消费端，消费端消费消息一般是这个流程：拉取消息、业务逻辑处理、提交消费位移。假设业务逻辑处理完，事务提交了，但是需要更新消费位移时，消费者挂了，这时候另一个消费者就会拉到重复消息了。

幂等处理重复消费：
- Redis缓存标记

## 消息积压
- 排查是否存在bug
- 批量处理消息
- 水平扩容，增加Topic的队列数



## 分布式事务
**分布式应用必定涉及到各个系统之间的通信问题**
![image.png](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404291641487.png)
1. 生产者产生消息，发送一条半事务消息到MQ服务器
2. MQ收到消息后，将消息持久化到存储系统，这条消息的状态是待发送状态。
3. MQ服务器返回ACK确认到生产者，此时MQ不会触发消息推送事件
4. 生产者执行本地事务
5. 如果本地事务执行成功，即commit执行结果到MQ服务器；如果执行失败，发送rollback。
6. 如果是正常的commit，MQ服务器更新消息状态为可发送；如果是rollback，即删除消息。
7. 如果消息状态更新为可发送，则MQ服务器会push消息给消费者。消费者消费完就回ACK。
8. 如果MQ服务器长时间没有收到生产者的commit或者rollback，它会反查生产者，然后根据查询到的结果执行最终状态。


# 模型
## 队列模型
多消费者：生产者需要知道具体消费者个数然后去复制对应数量的消息队列

## 主题模型


# RPC、消息队列、HTTP
## RPC 和消息队列的区别
RPC 和消息队列都是分布式微服务系统中重要的组件之一，下面我们来简单对比一下两者：

- **从用途来看**：RPC 主要用来解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。消息队列主要用来降低系统耦合性、实现任务异步、有效地进行流量削峰。
- **从通信方式来看**：RPC 是双向直接网络通讯，消息队列是单向引入中间载体的网络通讯。
- **从架构上来看**：消息队列需要把消息存储起来，RPC 则没有这个要求，因为前面也说了 RPC 是双向直接网络通讯。
- **从请求处理的时效性来看**：通过 RPC 发出的调用一般会立即被处理，存放在消息队列中的消息并不一定会立即被处理。

RPC 和消息队列本质上是网络通讯的两种不同的实现机制，两者的用途不同，万不可将两者混为一谈



# 参考
[十道经典消息队列面试题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/471374718)
[聊聊幂等设计 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzkyMzU5Mzk1NQ==&mid=2247506349&idx=1&sn=47b8ae3a94176440a6e5d5ad3505b4f3&source=41#wechat_redirect)
[如何设计一个牛逼的消息队列？ - 架构摆渡人 - 博客园 (cnblogs.com)](https://www.cnblogs.com/jiagoubaiduren/p/16213891.html)