---
title: Java：并发
description: 线程、锁、条件变量
categories: java
date: 2024-2-28
tags:
  - 并发
---
# 进程和线程
进程具有两个特点：
- 资源所有权：进程具有对资源的控制权和所有权，这些资源包括内存、I/O通道、I/O设备和文件等。
- 调度/执行：进程时可被操作系统调度和分派的实体
将分派的单位称为线程或轻量级进程

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

线程是程序执行的最小单位，同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**。

## 用户线程、内核线程
- 用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。
- 内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。
- 用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。

## 虚拟线程
**虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。** 许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。

在引入虚拟线程之前，`java.lang.Thread` 包已经支持所谓的平台线程，也就是没有虚拟线程之前，我们一直使用的线程。JVM 调度程序通过`平台线程`（载体线程）来管理`虚拟线程`，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。
![image.png](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405151057182.png)
关于平台线程和系统内核线程的对应关系多提一点：在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个平台线程对应一个系统内核线程。

相比较于平台线程来说，虚拟线程是廉价且轻量级的，使用完后立即被销毁，因此它们不需要被重用或池化，每个任务可以有自己专属的虚拟线程来运行。虚拟线程暂停和恢复来实现线程之间的切换，避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。

# 线程
## 线程分类
>用户级线程、内核级线程

- 用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。
- 内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。
![image.png](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403032054516.png)

用户线程：创建和切换成本低，不可以利用多核。内核一次把一个进程分配给一个处理器，一个进程中只有一个线程可以执行
内核线程：创建和切换成本高，需要从用户模式切换到内核模式，再切换回用户模式。可以利用多核。


## 线程状态和生命周期
![image.png|350](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403032125806.png)

- `NEW`: 初始状态，线程被创建出来但没有被调用 `start()` 。
- `RUNNABLE`: 运行状态，线程被调用了 `start()`等待运行的状态。
- `BLOCKED`：阻塞状态，需要等待锁释放。
- `WAITING`：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
- `TIME_WAITING`：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
- `TERMINATED`：终止状态，表示该线程已经运行完毕。

生命周期：程序的执行过程再不同状态之间切换

## 线程上下文切换
- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
- 被终止或结束运行



## 创建线程
>继承`Thread`类、实现`Runnable`接口、实现`Callable`接口、使用线程池、使用`CompletableFuture`类等

```java
new Thread()
```


>可以直接调用 Thread 类的 run 方法吗？
>直接调用run方法，只会执行通过一个线程中的任务，而不会启动新线程。应该调用Thread.start方法，这个方法将创建一个执行run方法的新线程。

new 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。



# 多线程
## 同步、异步
- **同步**：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
- **异步**：调用在发出之后，不用等待返回结果，该调用直接返回。
- 线程同步：多个线程合作，线程的执行需要满足某种时序关系

## 线程安全和不安全
线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其**正确性和一致性**的描述。
- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。


1. **线程安全**：
    - 线程安全指的是在多线程环境下，对共享数据的访问操作能够保证在并发情况下不会导致数据的不一致性或损坏。一个线程安全的操作或数据结构能够在并发访问时维持其内部状态的一致性。
    - 线程安全的实现通常会采用同步机制（例如锁、信号量等）来保护共享资源的访问，以确保在任意时刻只有一个线程能够访问共享资源，从而避免竞态条件（Race Condition）和其他并发问题。
2. **线程不安全**：
    - 线程不安全指的是在多线程环境下，对共享数据的访问操作可能会导致数据的不一致性或损坏。线程不安全的操作或数据结构在并发访问时无法保证其内部状态的一致性，可能会导致意外的结果或程序错误。
    - 线程不安全的实现通常没有考虑到并发访问的情况，没有采取适当的同步措施来保护共享资源的访问，因此可能会出现竞态条件和其他并发问题。

举例来说，如果多个线程同时尝试向同一个数组中添加元素，而该数组的添加操作没有进行适当的同步控制，那么就可能导致线程不安全的情况，如数据覆盖、越界访问等。为了保证线程安全，需要在并发访问共享资源时使用适当的同步机制来确保数据的一致性。

## 检测死锁

使用`jmap`、`jstack`等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，`jstack` 的输出中通常会有 `Found one Java-level deadlock:`的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用`top`、`df`、`free`等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。

# 线程同步
原子性：一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。
可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。
有序性：由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。
## volatile(可见性)
`可见性、不保证原子性、防止JVM的指令重排序`
>volatile 关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为volatile ,那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。
>保证变量的可见性。当一个变量被声明成volatile，JMM会确保所有线程看到这个变量的值是一致的。

volatile禁用CPU缓存，表示这个变量是共享且不稳定的，每次使用它都到主存中进行读取。


```java
volatile int inc=0;
inc++;  //volatile不能保证该操作的原子性
1. 读取 inc 的值。
2. 对 inc 加 1。
3. 将 inc 的值写回内存。
```


## 锁
### 乐观锁和悲观锁
`乐观锁`：每次获取资源都会上锁，只有持有者释放锁其他线程才可以访问共享资源。
`悲观锁`：线程可以不停地执行，无需加锁也无需等待，只是在==提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了==（具体方法可以使用版本号机制或 CAS 算法）。 Java 中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。**乐观锁主要针对的对象是单个共享变量**
`对比`：高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。
-  悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能
- 乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。

### 乐观锁实现
#### 版本号机制
一般是在数据表中加上一个数据版本号 `version` 字段，表示数据被修改的次数。当数据被修改时，`version` 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 `version` 值，**在提交更新时，若刚才读取到的 version 值为当前数据库中的 `version` 值相等时才更新**，否则重试更新操作，直到更新成功。

#### CAS(Compare And Swap)
>专用机器指令,CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。

![image.png](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403051047897.png)

CAS 涉及到三个操作数：
- **V**：要更新的变量值(Var)
- **E**：预期值(Expected)
- **N**：拟写入的新值(New)

当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。
#### CAS存在问题
##### ABA
如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，但是在这期间可能被修改为B值。
解决：在变量前追加版本号和时间戳
##### 循环时间长开销大
CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。

##### 只能保证一个共享变量的原子操作
CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了`AtomicReference`类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference`类把多个共享变量合并成一个共享变量来操作。



### 公平锁、非公平锁
- **公平锁** : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。
- **非公平锁**：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。

### 可中断锁、不可中断锁
- **可中断锁**：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。`ReentrantLock` 就属于是可中断锁。
- **不可中断锁**：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 `synchronized` 就属于是不可中断锁。

|               | 可见性 | 原子性 | 可重入 | 公平锁、非公平锁 | 可中断锁、不可中断 |
| ------------- | --- | --- | --- | -------- | --------- |
| volatile      | 是   |     |     |          |           |
| synchronized  | 是   | 是   | 是   | 非公平锁     |           |
| ReentrantLock |     |     | 是   | 公平锁、非公平锁 | 可中断锁      |
### 共享锁、独占锁
- **共享锁**：一把锁可以被多个线程同时获得。
- **独占锁**：一把锁只能被一个线程获得。
### synchronized（互斥性、可见性、有序性）
`保证数据可见性、保证数据原子性`
>每一个对象有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入synchronized 方法的线程， 由条件来管理那些调用wait 的线程。
>主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
```java
void notifyAll();
void notify();
void wait();
```
1. 修饰实例方法（获取对象实例锁）
2. 修饰静态方法（获取类的锁）
3. 修饰代码块（锁指定对象/类）
	1. `synchronized(object)` 表示进入同步代码库前要获得 **给定对象的锁**。
	2. `synchronized(类.class)` 表示进入同步代码前要获得 **给定 Class 的锁**

**构造方法不能使用 synchronized 关键字修饰。**
构造方法本身就属于线程安全的，不存在同步的构造方法一说。

[一文彻底搞懂synchronized实现原理-CSDN博客](https://blog.csdn.net/weixin_44772566/article/details/137398521)


#### JDK1.6 之后的 synchronized 底层做了哪些优化？锁升级原理了解吗？
在jdk1.5（包含）版本之前，因为加锁和释放锁的过程JVM的底层都是由操作系统mutex lock来实现的，其中会涉及上下文的切换（即用户态和内核态的转换），性能消耗极其高，所以在当时synchronized锁是公认的重量级锁。

在 Java 6 之后， `synchronized` 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 `synchronized` 锁的效率提升了很多（JDK18 中，偏向锁已经被彻底废弃，前面已经提到过了）。

锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

[浅析synchronized锁升级的原理与实现 - 小新成长之路 - 博客园 (cnblogs.com)](https://www.cnblogs.com/star95/p/17542850.html)

#### synchronized 和 volatile
- `volatile` 关键字是线程同步的轻量级实现，所以 `volatile`性能肯定比`synchronized`关键字要好 。但是 `volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块 。
- `volatile` 关键字能保证数据的**可见性**，但不能保证数据的原子性。`synchronized` 关键字两者都能保证，**原子性和可见性**。
- `volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。


### ReentrantLock(可重入锁)
>可重入、独占式锁、可中断锁

`ReentrantLock` 实现了 `Lock` 接口，是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。

```
ReentrantLock( ) 构建一个可以被用来保护临界区的可重入锁。
ReentrantLock(boo1ean fair ) 构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但是，这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。
```



#### synchronized 和 ReentrantLock
> **两者都是可重入锁**

可重入锁也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。

>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API



>ReentrantLock增加一些高级功能
- **等待可中断** : `ReentrantLock`提供了一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()` 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
- **可实现公平锁** : **ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁**。所谓的公平锁就是先等待的线程先获得锁。`ReentrantLock`默认情况是非公平的，可以通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来指定是否是公平的。
- **可实现选择性通知（锁可以绑定多个条件）**: `synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition()`方法。

### ReentrantReadWriteLock
>适用于读请求多的情景
  读锁：共享锁
  写锁：独占锁


## 条件变量
>线程进入临界区，但需要某一条件满足才可以执行。
>通过条件变量管理获得一个锁但不能做有用工作的线程。

```java
Condition cond;

//将线程放入条件的等待集中，会释放锁
while(!(ok to proceed))
	cond.await(); 
	
cond.signalAll();

//解除等待集中某个线程的阻塞状态
cond.signal();
```


```
mu.Lock()
// do something that might affect the condition
cond.Broadcast()
mu.Unlock()

----

mu.Lock()
while condition == false {
	cond.Wait()
}
// now condition is true, and we have the lock
mu.Unlock()
```


# 同步器
信号量

同步队列


# Future、Runnable、Callable
## Runnable、Callable
**`Runnable` 接口**不会返回结果或抛出检查异常，但是 **`Callable` 接口**可以。
工具类 `Executors` 可以实现将 `Runnable` 对象转换成 `Callable` 对象。（`Executors.callable(Runnable task)` 或 `Executors.callable(Runnable task, Object result)`）。

`Runnable.java`

```
@FunctionalInterface
public interface Runnable {
   /**
    * 被线程执行，没有返回值也无法抛出异常
    */
    public abstract void run();
}
```

`Callable.java`

```java
@FunctionalInterface
public interface Callable<V> {
    /**
     * 计算结果，或在无法这样做时抛出异常。
     * @return 计算得出的结果
     * @throws 如果无法计算结果，则抛出异常
     */
    V call() throws Exception;
}
```
## execute()、submit()

# JMM（Java内存模型）
JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。

- **主内存**：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。
- **本地内存**：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。
![image.png](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405161021546.png)

## Java内存区域和JMM
- **JVM 内存结构和 Java 虚拟机的运行时区域相关**，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。
- **Java 内存模型和 Java 的并发编程相关**，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。多线程环境下对共享变量的访问


# Java并发容器
- **`ConcurrentHashMap`** : 线程安全的 `HashMap`
- **`CopyOnWriteArrayList`** : 线程安全的 `List`，在读多写少的场合性能非常好，远远好于 `Vector`。
- **`ConcurrentLinkedQueue`** : 高效的并发队列，使用链表实现。可以看做一个线程安全的 `LinkedList`，这是一个非阻塞队列。
- **`BlockingQueue`** : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
- **`ConcurrentSkipListMap`** : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。

## BlockingQueue
- ArrayBlockingQueue
- LinkedBlockingQueue
- PriorityBlockingQueue