---
title: MySQL(1)：存储引擎、索引
description: SQL语句执行流程、索引(覆盖索引、联合索引、索引下推)、索引优化、索引失效
top: 9
categories: 数据库
tags:
  - MySQL
date: 2024-03-07
---

# 字段类型
![image.png|500](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252156220.png)

# MySQL基础架构
![image.png|500](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252206970.png)
MySQL 可以简单分为 Server 层和存储引擎层这两层，MySQL 支持 InnoDB、MyISAM、Memory 等多种存储引擎。
- Server 层负责建立连接、分析和执行SQL。所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。
- 引擎层负责数据的存储和读取

## SQL语句执行流程
### 1. 连接器（长连接、短连接）
	- 与客户端进行 TCP 三次握手建立连接；
	- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
	- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限
### 2. 查询缓存
### 3. 解析SQL语句（解析器）
	- 词法分析
	- 语法分析
### 4. 执行SQL
#### 预处理器：
- 检查 SQL 查询语句中的表或者字段是否存在；
- 将 `select *` 中的 `*` 符号，扩展为表上的所有列；

#### 优化器：
- 优化器主要负责将 SQL 查询语句的执行方案确定下来，为SQL语句指定**执行计划**（选择某个索引，explain）

#### 执行器：与存储引擎交互

- 主键索引查询
- 全表扫描
- 索引下推：索引下推能够减少**二级索引**在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。

[执行一条 select 语句，期间发生了什么？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/base/how_select.html#%E6%89%A7%E8%A1%8C%E5%99%A8)


## MySQL一行记录存储
![image.png](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405132123653.png)
### NULL值列表：
如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。
### 记录头信息
- delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。
- next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
- record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录
### 记录的真实数据
- row_id：如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。

- trx_id：`事务id`，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。

- roll_pointer：这条记录`上一个版本的指针`。roll_pointer 是必需的，占用 7 个字节。

> MySQL 的 NULL 值是怎么存放的？

MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。

NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。

> MySQL 怎么知道 varchar(n) 实际占用数据的大小？

MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。


# MySQL存储引擎
## MyISAM和InnoDB
- **是否支持行级锁**：MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
- **是否支持事务**：MyISAM 不提供事务支持。
- 是否支持外键：MyISAM 不支持，而 InnoDB 支持。
- **是否支持数据库异常崩溃后的安全恢复**：MyISAM 不支持，而 InnoDB 支持。
- **是否支持 MVCC**：MyISAM 不支持，而 InnoDB 支持。
- **索引实现不一样**：都使用B+Tree作为索引结构，InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。

## 存储引擎(MyISAM, InnoDB)

- ==事务支持==： InnoDB支持事务，具有提交、回滚和崩溃恢复能力，可以保护用户数据。它使用了一种称为“写前日志”（write-ahead logging，WAL）的技术，先写日志，再写数据，保证了事务的完整性。 MyISAM不支持事务，这意味着在MyISAM中进行的更改无法回滚，且如果发生崩溃，数据可能会损坏。
- ==锁机制==： InnoDB支持行级锁和表级锁，但默认使用行级锁。行级锁可以提高并发性能，因为它只锁定被访问的行，而不是整个表。 MyISAM只支持表级锁，这意味着当一个线程正在对一个表进行写操作时，其他线程无法对该表进行读或写操作。这可能会降低并发性能。
- 外键支持： InnoDB支持外键约束，这有助于维护数据的引用完整性和一致性。 MyISAM不支持外键约束。
- ==数据存储和索引==： InnoDB使用聚簇索引来组织数据，表数据和主键索引存储在一起。此外，InnoDB还支持全文索引和哈希索引。 MyISAM将数据和索引分开存储，数据文件（MYD）和索引文件（MYI）是分离的。MyISAM也支持全文索引，但不支持哈希索引。
- 数据恢复和备份： InnoDB提供了更好的数据恢复功能，如通过binlog进行点时间恢复（PITR）。此外，InnoDB还支持在线备份功能。 MyISAM的数据恢复相对较弱，通常依赖于物理备份和恢复。
- ==性能==： InnoDB在处理大量读写操作时通常表现更好，特别是在高并发环境下。这得益于其行级锁和事务支持。 MyISAM在处理只读查询时可能更快，特别是当数据量很大且内存充足时。然而，在写操作频繁的场景下，MyISAM的性能可能会下降。
- 存储空间： InnoDB的存储空间通常比MyISAM大，因为它需要额外的空间来存储事务日志、行级锁等信息。此外，InnoDB的数据文件大小是动态增长的。 MyISAM的存储空间相对较小，数据文件大小是固定的（可以通过配置修改）。但是，MyISAM不支持数据压缩功能。
  
  
## MVCC（多版本并发控制）

多版本并发控制（MVCC，Multiversion Concurrency Control），是行级锁的变种，在很多情况下避免了加锁操作，因此开销更低。实现了非阻塞的读操作，写操作也只锁定必要的行。

**通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。**

MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，
每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据
可能是不一样的。

InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创
建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号
（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号
会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。
![image.png](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252225650.png)

**MVCC** 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。

MVCC 在 MySQL 中实现所依赖的手段主要是: **隐藏字段、read view、undo log**。
- undo log : undo log 用于记录某行数据的多个版本的数据。
- read view 和 隐藏字段 : 用来判断当前版本数据的可见性。

[InnoDB存储引擎对MVCC的实现 | JavaGuide](https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html)
# 索引
>**索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。**
>索引（MySQ中也叫做“键"）是存储引擎用于快速找到记录的一种数据结构

![image.png](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404182021221.png)

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：
- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；
## 底层数据结构

### AVL树
>在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 **磁盘 IO 是一项耗时的操作**

### 红黑树




### 为什么选择B+树作为索引
- B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
- B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
- B+ 树叶子节点之间用链表连接了起来，有利于**范围查询**，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

## 索引类型

- 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
- 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
- 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
- 按「字段个数」分类：单列索引、联合索引。
  
### 数据结构
#### B-Tree索引
>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据

![image.png|500](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403241636295.png)

>MyISAM索引通过数据的物理位置引用被索引的行，B+Tree 叶节点的 data 域存放的是数据记录的地址（非聚簇索引），索引文件和数据文件分离
  InnoDB则根据主键引用被索引的行。其数据文件本身就是索引文件。 InnoDB 表数据文件本身就是主索引，辅助索引的 data 域存储相应记录主键的值而不是地址。


![](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405141106447.png)
##### 可以使用B-Tree索引的查询类型
- 全值匹配：全值匹配指的是和索引中的所有列进行匹配
- 匹配最左前缀
- 匹配列前缀：也可以只匹配某一列的值的开头部分
- 匹配范围值
- 精确匹配某一列并范围匹配另外一列

#### 哈希索引
>不支持顺序和范围查询

### 物理存储

#### 主键索引与二级索引
主键索引：聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点
二级索引：叶子节点存放的是主键值，而不是实际数据。

在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是**覆盖索引**。

如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是**回表**。
#### 聚簇(集)索引与非聚簇(集)索引
- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。
![image.png|500](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252328222.png)

聚簇索引优缺点：
- 二级索引访问需要两次索引查找，而不是一次。二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。InnoDB在移动行或者数据页分裂时无须更新二级索引中的这个“指针”。

![image.png|475](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252334238.png)


### 覆盖索引与联合索引
覆盖索引
- 使用索引来直接获取列的数据，这样就不再需要读取数据行
- 如果一个**索引包含（或者说覆盖）所有需要查询的字段的值**，我们就称之为“覆盖索引”。

联合索引
- 使用表中的多个字段创建索引，就是 **联合索引**，也叫 **组合索引** 或 **复合索引**。

### 冗余索引和重复索引
冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引

### 前缀索引
使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。

### 联合索引和单列索引
联合索引底层存储结构(和其他种类的索引的存储结构有什么区别?)

联合索引是数据库中一种常见的索引类型，它允许在多个列上创建索引，以提高查询性能。与单列索引相比，联合索引的底层存储结构有一些区别，主要体现在如何组织和存储索引数据的方式上。
1. **存储数据的组织方式**：    
    - 单列索引：单列索引只包含一个列的值和指向相应数据行的指针。通常，单列索引按照列值的大小顺序来组织存储数据。
    - 联合索引：**联合索引则包含多个列的值，以及指向相应数据行的指针**。联合索引可以按照多个列值的组合来组织存储数据，这意味着可以根据多个列的值来定位数据行。
2. **查询时的性能影响**：
    - 单列索引：单列索引适合用于只涉及单个列的查询。当查询条件涉及到索引列时，数据库可以更快地定位到匹配的数据行。
    - 联合索引：联合索引适合用于涉及多个列的查询。当查询涉及到联合索引中的多个列时，数据库可以利用索引中列值的组合来快速定位匹配的数据行。
3. **索引维护的复杂性**：
    - 单列索引：单列索引的维护相对简单，因为它只需要维护单个列的值和指针。
    - 联合索引：联合索引的维护相对复杂一些，因为它需要考虑多个列值的组合。当表中的数据发生变化时，数据库需要确保联合索引中的多个列值的组合保持有序，这可能需要更多的资源和时间。

联合索引在适当的情况下可以提供更好的查询性能，特别是对于涉及到联合索引中列值的组合的查询。然而，需要注意的是，联合索引的创建和维护可能会带来一些额外的开销，并且需要根据具体的查询需求和数据模式来合理选择索引策略。

  

## 索引的优点（三星评价）
索引将相关的记录放到一起则获得一星；
如果索引中的数据顺序和查找中的排列顺序一致则获得二星；
如果索引中的列包含了查询中需要的全部列则获得“三星”。


## 最左匹配
查询只能使用索引的最左前缀，直到遇到第一个范围条件列。
最左前缀匹配原则指的是在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。

最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、<）为止，范围查询的字段可以用到联合索引。对于 >=、<=、BETWEEN 以及==前缀匹配 LIKE== 的范围查询，不会停止匹配

当MySQL使用联合索引进行查询时，会从索引的最左边开始匹配查询条件，如果查询条件中包含了索引左边的列，那么MySQL才可能会使用这个索引来优化查询。如果查询条件没有包含左边的列或者左边的列出现一些范围查询（>、<、between等），即使其他列都在索引中，MySQL也可能不会使用这个索引。  
  

## 索引下推
将Server层筛选数据的工作，下推到引擎层处理。

在没有索引下推的情况下，MySQL会先从索引中获取所有可能满足条件的数据行的主键，然后根据这些主键检索完整的数据行(即回表)，最后再应用WHERE条件进行过滤。而有了索引下推，MySQL可以在扫描索引的同时，直接**根据索引中的值来判断是否满足WHERE条件**，从而避免不必要的回表操作。

对于联合索引\(a,b\)，在执行 `select * from table where a > 1 and b = 2` 语句的时候，只有 a 字段能用到索引。在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后：
- 不使用索引下推：从ID=2（主键值）回表，在主键索引中找出数据行，在对比b字段值
- 索引下推：**可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**。（Using index condition）

对于联合索引，在遇到范围查询时，后面的索引无法被用到。不使用索引下推，则根据主键值回表查询。但是可以根据索引包含的字段先做判断
## 什么时候需要 / 不需要创建索引？
索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：
- 需要占用物理空间，数量越大，占用空间越大；
- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；
- 会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。

所以，索引不是万能钥匙，它也是根据场景来使用的。

#### 什么时候适用索引？
- 字段有`唯一性`限制的，比如商品编码；
- 经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

#### 什么时候不需要创建索引？
- `WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- `字段不具有区分度`，字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
- 表数据太少的时候，不需要创建索引；
- `经常更新的字段`不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。


## 索引优化
- 前缀索引优化：使用字符串的前几个字符建立索引，减少索引字段大小
- 覆盖索引：要查询的字段，在叶子节点上都能找到对应的索引
- 主键索引最好是自增的：每次插入一条新记录，都是追加操作，不需要重新移动数据
- 索引最好设置为NOT NULL
- 防止索引失效，最左前缀匹配

**如果我们使用非自增主键**，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为**页分裂**。**页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率**。

## 索引失效
- 使用左或者左右**模糊匹配**的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 在查询条件中**对索引使用函数**，即对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
- 联合索引要能正确使用需要遵循**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

```
//对索引进行表达式计算
EXPLAIN select * from department where dept_id+1=10;
EXPLAIN select * from department where dept_id=11;

//对索引使用函数
EXPLAIN select * from department where LENGTH(dept_name)=5;
ALTER TABLE department add key idx_name_length ((LENGTH(dept_name)));
```


## Count
count(1)、 count(\*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。

所以，如果要执行 count(1)、 count(\*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。

再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。

# 执行计划
- possible_keys 字段表示可能用到的索引；
- key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；
- key_len 表示索引的长度；
- rows 表示扫描的数据行数。
- type 表示数据扫描类型，我们需要重点看这个。
## type

- All（全表扫描）；
- index（全索引扫描）；
- range（索引范围扫描）；
- ref（非唯一索引扫描）；
- eq_ref（唯一索引扫描）；
- const（结果只有一条的主键或唯一索引扫描）。

## extra

- Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。
- Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。
- Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。



![image.png](https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404182127269.png)

